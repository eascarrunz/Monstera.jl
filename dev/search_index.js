var documenterSearchIndex = {"docs":
[{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Tree data structures must implement their own types for trees, nodes, and branches, which ought to be subtypes of AbstractTree, AbstractNode, and AbstractBranch, respectively. As an example, let's call them MyTree, MyNode, and MyBranch.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"struct MyBranch <: AbstractBranch\n    # ...<Implementation details>...\nend\n\nstruct MyNode <: AbstractNode\n    # ...<Implementation details>...\nend\n\nstruct MyTree <: AbstractTree\n    # ...<Implementation details>...\nend","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The Monstera interface requires us to indicate that those types match each other by implementing the following methods:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"treetype(::Type{MyNode}) = MyTree\ntreetype(::Type{MyBranch}) = MyTree\n\nnodetype(::Type{MyTree}) = MyNode\nnodetype(::Type{MyBranch}) = MyNode\n\nbranchtype(::Type{MyTree}) = MyBranch\nbranchtype(::Type{MyNode}) = MyBranch","category":"page"},{"location":"interface/#Node-types","page":"Interface","title":"Node types","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Required public properties Default value Description User settable\nid::PhyloInd 0 (should be set at tree construction) Numerical identifier of the node No\ntaxon::PhyloInd 0 (= no taxon) Numerical identifier of the taxon associated to the node Yes\nlabel::String \"\" Label for display Yes","category":"page"},{"location":"interface/#Branch-types","page":"Interface","title":"Branch types","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Required public properties Default value Description User settable\nid::PhyloInd 0 (should be set at tree construction) Numerical identifier of the branch No\nlength::Float64 NaN Length of the branch Yes","category":"page"},{"location":"interface/#Tree-types","page":"Interface","title":"Tree types","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Required public properties Default value Description User settable\ntaxonset::Union{Nothing,TaxonSet} nothing Set of taxa represented in the tree Yes\nroot::Union{Nothing,MyNode} nothing Access point to the tree Yes\nnodes - Collection with settable indices listing all the nodes associated to the tree No\nbranches - Collection with settable indices listing all the branches associated to the tree No","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Tree types must have a constructor with the signature MyTree(taxonset::Union{Nothing,TaxonSet}, n). The constructor initialises the tree with n nodes (n > 0) and n - 1 branches.","category":"page"},{"location":"interface/#Mandatory-methods","page":"Interface","title":"Mandatory methods","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Mandatory methods pertaining to the interconnections among branches and nodes follow a.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Required methods Brief description\nneighbours(node) Return a branch => node iterator of the neighbours of a node\nchildren(branch => node) Return a branch => node iterator of the children of node as seen coming from branch\nhasparent(node) Check whether the node as an intrinsic parent\nparent(branch => node) Return the parent of a node, as seen coming  from branch\nnodes_flanking(branch) Return a tuple with the nodes connected to a branch\nlink!(node1, branch, node2) Link two nodes through a branch, in left-to-right direction\nunlink!(node1, node2) Unlink two nodes and return the branch that was connecting them","category":"page"},{"location":"#Monstera.jl-Documentation","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"","category":"section"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"CurrentModule = Monstera","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"This is an experimental package for phylogenetics in Julia.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"These are the main objectives of this package:","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Provide a general interface for basic operations with phylogenetic trees, allowing the ","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"experimentation with a variety of data structures to represent trees","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Allow as much flexibility as possible:\nTaxa can live in inner or outer nodes\nNon-splitting nodes are permitted\nBe ergonomic for interactive use","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Only one base tree type is available for now: RoundaboutTree (see below).","category":"page"},{"location":"#Quick-Introduction","page":"Monstera.jl Documentation","title":"Quick Introduction","text":"","category":"section"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Let's start off loading a tree in Newick format. This is a little extract of the tree of the Araceae from Haigh et al. (2022): ","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> philo_string = \"(((Philodendron,Adelonema),(Homalomena,Furtadoa)),(Cercestis,Culcasia),Monstera);\";\n","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"We can create a tree object from that string using the Newick.parse method, and specifying the tree type that we want. Only one tree type is available for now: RoundaboutTree. Optionally, we can create a TaxonSet from the labels of the tree.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> philo_tree = Newick.parse(RoundaboutTree, philo_string, TaxonSet())\nRoundaboutTree: 12 nodes, 11 branches","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Let's take a look at it. The textplot function will print a diagram of the tree:","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> textplot(philo_tree)\n             ┌───────●(4)Philodendron\n     ┌───────○(3)\n     │       └───────●(5)Adelonema\n┌────○(2)\n│    │       ┌───────●(7)Homalomena\n│    └───────○(6)\n│            └───────●(8)Furtadoa\n○(1)\n│    ┌───────●(10)Cercestis\n├────○(9)\n│    └───────●(11)Culcasia\n│\n└────●(12)Monstera","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Nodes are represented by small circles, with numerical identifiers in parentheses. Next to that, node labels are shown. Nodes are objects, and they can be retrieved from the tree by their IDs. For instance, let's take a look at nodes #3 and #4, and their main properties.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> philo_tree.nodes[3]\nRoundaboutNode #3 (no taxon)\njulia> philo_tree.nodes[3].id\n3\njulia> philo_tree.nodes[3].taxon\n0\njulia> philo_tree.nodes[3].label\n\"\"\njulia> philo_tree.nodes[4]\nRoundaboutNode #4 (taxon 1) - \"Philodendron\"\njulia> philo_tree.nodes[4].id\n4\njulia> philo_tree.nodes[4].taxon\n1\njulia> philo_tree.nodes[4].label\n\"Philodendron\"","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Nodes can be associated to a taxon with its own numeric ID in a TaxonSet, or have no taxon (interally represented with a 0). Also, the diagram from textplot represents nodes with  taxa as filled circles. The taxon set is property of the tree, accessible as philo_tree.taxonset. A single taxon set object is shared with groups of trees that represent the same group of taxa.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Branches are have IDs, like nodes, and are accessible with the branches property.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> philo_tree.branches\n11-element Vector{RoundaboutBranch}:\n RoundaboutBranch #1: 1 ○⎯⎯⎯○ 2 (length NaN)\n RoundaboutBranch #2: 2 ○⎯⎯⎯○ 3 (length NaN)\n RoundaboutBranch #3: 3 ○⎯⎯⎯● 4 (length NaN)\n RoundaboutBranch #4: 3 ○⎯⎯⎯● 5 (length NaN)\n RoundaboutBranch #5: 2 ○⎯⎯⎯○ 6 (length NaN)\n RoundaboutBranch #6: 6 ○⎯⎯⎯● 7 (length NaN)\n RoundaboutBranch #7: 6 ○⎯⎯⎯● 8 (length NaN)\n RoundaboutBranch #8: 1 ○⎯⎯⎯○ 9 (length NaN)\n RoundaboutBranch #9: 9 ○⎯⎯⎯● 10 (length NaN)\n RoundaboutBranch #10: 9 ○⎯⎯⎯● 11 (length NaN)\n RoundaboutBranch #11: 1 ○⎯⎯⎯● 12 (length NaN)","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Little diagrams of the branches show the nodes to which they are attached. We have no branch lengths in this example, so the \"length\" value is set to NaN.","category":"page"},{"location":"#Orientation-conventions-and-the-branch-node-notation","page":"Monstera.jl Documentation","title":"Orientation conventions and the branch => node notation","text":"","category":"section"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"This is a central concept in the Monstera package. Tree objects can have an intrinsic  orientation, so that branches are directed outward from the root node. Monstera also makes  it possible to traverse the tree in any arbitrary direction by means of special conventions  in function calls. For instance, if we have a function f that traverses a tree, or a  sub-tree of a tree, we can call f in a number of ways to indicate exactly what part of the  tree to traverse, and in what direction:","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Notation Meaning\nf(tree) Traverse the entire tree starting from its root node\nf(node) Traverse the part of the tree that descends from a node, following to the intrinsic orientation of the tree\nf(nothing => node) Traverse the entire tree as if it were rooted on a node\nf(branch => node) Traverse the part of the tree that descends from a node, with the parent-child direction indicated by the branch-node pair","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"The textplot function is one of the many functions that work in this way. It prints a  diagram of the tree, or a sub-tree, using characters on a terminal window.  Let's see it in  action. First, we create a tree from a Newick string, and we plot it with  textplot(tree). The tree is plotted from left to right, from its root node.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> tree = Newick.parse(RoundaboutTree, \"(((A,B),C),(D,E),H);\");\n\njulia> textplot(tree)\n             ┌───────○(4)A\n     ┌───────○(3)\n┌────○(2)    └───────○(5)B\n│    │\n│    └───────○(6)C\n│\n○(1) ┌───────○(8)D\n├────○(7)\n│    └───────○(9)E\n│\n└────○(10)H","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"As node #1 is the root node, textplot(tree.nodes[1]) or textplot(tree.root) produces an  identical result.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> textplot(tree.nodes[1])\n             ┌───────○(4)A\n     ┌───────○(3)\n┌────○(2)    └───────○(5)B\n│    │\n│    └───────○(6)C\n│\n○(1) ┌───────○(8)D\n├────○(7)\n│    └───────○(9)E\n│\n└────○(10)H","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"If we do the same with node #2 instead, we get the corresponding sub-tree.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> textplot(tree.nodes[2])\n     ┌───────○(4)A\n┌────○(3)\n○(2) └───────○(5)B\n│\n└────○(6)C","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"The branch => node notation gives us a more flexible way to plot sub-trees, but we need to know which branches are connecting which nodes. We get the information we need just by  showing the branch list on the REPL.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> tree.branches\n9-element Vector{RoundaboutBranch}:\n RoundaboutBranch #1: 1 ○⎯⎯⎯○ 2 (length NaN)\n RoundaboutBranch #2: 2 ○⎯⎯⎯○ 3 (length NaN)\n RoundaboutBranch #3: 3 ○⎯⎯⎯○ 4 (length NaN)\n RoundaboutBranch #4: 3 ○⎯⎯⎯○ 5 (length NaN)\n RoundaboutBranch #5: 2 ○⎯⎯⎯○ 6 (length NaN)\n RoundaboutBranch #6: 1 ○⎯⎯⎯○ 7 (length NaN)\n RoundaboutBranch #7: 7 ○⎯⎯⎯○ 8 (length NaN)\n RoundaboutBranch #8: 7 ○⎯⎯⎯○ 9 (length NaN)\n RoundaboutBranch #9: 1 ○⎯⎯⎯○ 10 (length NaN)","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Since branch #1 connects node #1 (the root) to node #2,  textplot(tree.branches[1] => tree.nodes[2]) will print the same sub-tree as in the  previous example.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> textplot(tree.branches[1] => tree.nodes[2])\n     ┌───────○(4)A\n┌────○(3)\n○(2) └───────○(5)B\n│\n└────○(6)C","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"With the branch => node notation, we can plot sub-trees with a completely different  orientation, without actually changing the root of the tree. The key is that we consider the given branch as coming from the parent of the node. Take a look at the following  example:","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> textplot(tree.branches[2] => tree.nodes[2])\n┌────○(6)C\n│\n○(2)         ┌───────○(8)D\n│    ┌───────○(7)\n└────○(1)    └───────○(9)E\n     │\n     └───────○(10)H","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Branch #2 connects node #2 to node #3, so we are in effect plotting the sub-tree of node #2 as though node #3 were its parent. Hence, node #1, the true root of the tree, appears as a descendant of node #2, and node #3 is left out.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"The branch => node notation also gives us the ability to plot the entire tree as though  any node were the root of the tree. Since a \"proper\" root node has no parent, we replace the branch with nothing, like so:","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> textplot(nothing => tree.nodes[2])\n     ┌───────○(4)A\n┌────○(3)\n│    └───────○(5)B\n│\n○(2)─○(6)C\n│\n│            ┌───────○(8)D\n│    ┌───────○(7)\n└────○(1)    └───────○(9)E\n     │\n     └───────○(10)H","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"The usefulness of having all these options for defining tree orientations might not be  obvious in common use cases, but it has practical value. For instance, in many cases the root of the tree might not be biologically meaningful, such as in trees inferred by  maximum-likelihood without an explicit outgroup.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Also, some important algorithms require  treating any arbitrary node as the root of the tree, as in maximum-likelihood branch length  optimisation.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Finally, the branch => node notation also a useful return value of many functions. The children function, for instance, returns an iterator of branch => node  pairs: instead of just listing the children nodes, we get the corresponding branch and node of each child.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> collect(children(tree.branches[2] => tree.nodes[2]))\n2-element Vector{Pair{RoundaboutBranch{RoundaboutNode}, RoundaboutNode}}:\n RoundaboutBranch #5 => RoundaboutNode #6 (no taxon) - \"C\"\n RoundaboutBranch #1 => RoundaboutNode #1 (no taxon)","category":"page"},{"location":"#The-RoundaboutTree-type","page":"Monstera.jl Documentation","title":"The RoundaboutTree type","text":"","category":"section"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"This type implements a complex data structure based on circular linked lists of branches  surrounding nodes: \"roundabouts\" of branches. The use of linked lists makes the construction  and modification of trees very fast, as it avoids allocations associated to array-based   lists. This comes at the cost of complexity and indirections that slow down tree   traversals.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Each RoundaboutBranch object has a \"left\" and \"right\" side. They correspond to the  \"parent\" and \"child\" sides of the branch, following the orientation in which the tree was  constructed, for instance, from a Newick string.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Each side of a branch contain fields with the following information:","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"A reference to the RoundaboutNode connected by this side, or nothing if there is no node yet (this should only happen in intermediate stages of tree construction or branch swapping)\nA reference to the next RoundaboutBranch connected to this side's node. If there are no","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"other branches, this field points back to the present branch.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"An instance of the side type of the next RoundaboutBranch which is connected to this side's node.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Side types are RoundaboutLeft, RoundaboutRight and RoundaboutNoSide; subtypes of RoundaboutSide.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"The RoundaboutNode objects contain a reference to the last RoundaboutBranch that was connected to them. This provides quick access to both the head and tail of the circular  list.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"The RoundaboutTree data structure is a spin on Felsenstein's nodelet-based tree data  structure (Felsenstein 2004), used in PHYLIP and in the Phylogenetic Likelihood Library used by RAxML-NG. I replaced the pairs of \"nodelets\" pointing back to each other with single  branches that contain two sides. I also made nodes concrete objects, insetad of emerging  properties of cycles of nodelets. The advantage is that this structure fits a generic tree  interface better, and it is conceptually simpler and easier to use in interactive  programming.","category":"page"},{"location":"docstrings/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"docstrings/","page":"Functions","title":"Functions","text":"CurrentModule = Monstera","category":"page"},{"location":"docstrings/#Managing-sets-of-taxa","page":"Functions","title":"Managing sets of taxa","text":"","category":"section"},{"location":"docstrings/","page":"Functions","title":"Functions","text":"TaxonSet\nget(::TaxonSet, ::String)\nkey(::TaxonSet, ::Any...)\nhaskey\nkeys(::TaxonSet)\nadd!(::TaxonSet, ::String...)","category":"page"},{"location":"docstrings/#Monstera.TaxonSet","page":"Functions","title":"Monstera.TaxonSet","text":"TaxonSet([taxon_names])\nTaxonSet(n::Int)\n\nAn ordered collection of taxa with unique names.\n\nTaxonSets can be created empty, or from a vector of name strings, or by giving a number n, which creates taxa successively named \"1\" through \"n\".\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Base.get-Tuple{TaxonSet, String}","page":"Functions","title":"Base.get","text":"get(taxonset, name)\n\nGet the taxon ID that matches a name in a taxon set, or return 0 if there is no match.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.key-Tuple{TaxonSet, Vararg{Any}}","page":"Functions","title":"Monstera.key","text":"key(taxonset, ids...)\n\nGet the names of the taxa with the given ids in the taxon set.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.haskey","page":"Functions","title":"Base.haskey","text":"haskey(collection, key) -> Bool\n\nDetermine whether a collection has a mapping for a given key.\n\nExamples\n\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char, Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> haskey(D, 'a')\ntrue\n\njulia> haskey(D, 'c')\nfalse\n\n\n\n\n\nhaskey(sc,k)\n\nReturns true if key k is present for SortedDict, SortedMultiDict or SortedSet sc. For SortedSet, haskey(sc,k) is a synonym for in(k,sc). For SortedDict and SortedMultiDict, haskey(sc,k) is equivalent to in(k,keys(sc)). Time: O(c log n)\n\n\n\n\n\nhaskey(sc,k)\n\nReturns true if key k is present for SortedDict, SortedMultiDict or SortedSet sc. For SortedSet, haskey(sc,k) is a synonym for in(k,sc). For SortedDict and SortedMultiDict, haskey(sc,k) is equivalent to in(k,keys(sc)). Time: O(c log n)\n\n\n\n\n\nhaskey(sc,k)\n\nReturns true if key k is present for SortedDict, SortedMultiDict or SortedSet sc. For SortedSet, haskey(sc,k) is a synonym for in(k,sc). For SortedDict and SortedMultiDict, haskey(sc,k) is equivalent to in(k,keys(sc)). Time: O(c log n)\n\n\n\n\n\nhaskey(collection, key) -> Bool\n\nDetermine whether a collection has a mapping for a given key.\n\nExamples\n\njulia> D = RobinDict('a'=>2, 'b'=>3)\nRobinDict{Char,Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> haskey(D, 'a')\ntrue\n\njulia> haskey(D, 'c')\nfalse\n\n\n\n\n\nhaskey(collection, key) -> Bool\n\nDetermine whether a collection has a mapping for a given key.\n\nExamples\n\njulia> D = OrderedRobinDict('a'=>2, 'b'=>3)\nOrderedRobinDict{Char,Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> haskey(D, 'a')\ntrue\n\njulia> haskey(D, 'c')\nfalse\n\n\n\n\n\nhaskey(collection, key) -> Bool\n\nDetermine whether a collection has a mapping for a given key.\n\nExamples\n\njulia> D = SwissDict('a'=>2, 'b'=>3)\nSwissDict{Char,Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> haskey(D, 'a')\ntrue\n\njulia> haskey(D, 'c')\nfalse\n\n\n\n\n\nhaskey(tree, key)\n\nReturns true if key is present in the tree, else returns false.\n\n\n\n\n\nhaskey(taxonset, name)\n\nCheck whether a taxon set contains a name.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Base.keys-Tuple{TaxonSet}","page":"Functions","title":"Base.keys","text":"keys(taxonset)\n\nReturn the list of names of taxa in a taxon set.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.add!-Tuple{TaxonSet, Vararg{String}}","page":"Functions","title":"Monstera.add!","text":"add!(taxonset, names...)\n\nAdd name(s) to a taxon set and return its id.\n\nNames already in the taxon set will be ignored (skipped or return 0).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Creating-trees","page":"Functions","title":"Creating trees","text":"","category":"section"},{"location":"docstrings/","page":"Functions","title":"Functions","text":"clone\nrandtree","category":"page"},{"location":"docstrings/#Monstera.clone","page":"Functions","title":"Monstera.clone","text":"clone(tree)\n\nCreate a copy of a tree.\n\nThe copied tree has the same topology and properites, but its contents are fully  independent. Only the taxon set is shared between the original tree and the clone.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.randtree","page":"Functions","title":"Monstera.randtree","text":"randtree(T, taxonset, rooted=true)\nrandtree(T, n, rooted=true)\n\nCreate a random binary tree of type T with the given taxon set, or the given number n of  outer nodes.\n\nIf rooted is false, the tree will be unrooted, i.e. it will have a basal trichotomy (this requires at least 3 outer nodes).\n\nRandom.seed!(1)\ntextplot(randtree(RoundaboutTree, 5, false))\n\n# output\n\n┌────○(2)\n│\n│    ┌───────○(5)\n○(1)─○(3)\n│    └───────○(6)\n│\n│    ┌───────○(7)\n└────○(4)\n     └───────○(8)\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Reading-and-writing-Newick-trees","page":"Functions","title":"Reading and writing Newick trees","text":"","category":"section"},{"location":"docstrings/","page":"Functions","title":"Functions","text":"Newick.parse\nNewick.read\nNewick.string\nNewick.write\nNewick.WriterSettings\nNewick.ReaderSettings","category":"page"},{"location":"docstrings/#Monstera.Newick.parse","page":"Functions","title":"Monstera.Newick.parse","text":"Newick.parse(T, string, settings)\n\nParse a string in Newick format as a tree of type T.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.Newick.read","page":"Functions","title":"Monstera.Newick.read","text":"Newick.read(file, sink)\nNewick.read(io, sink)\n\nRead trees from a file in Newick format.\n\nThe sink argument specifies the concrete type that will be used to represent the trees. It can correspond to an AbstractTree subtype or a vector thereof. If a tree type is given, only the first Newick string in the file will be read. If a vector of a tree type is given,  all the Newick strings in the file will be read.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.Newick.string","page":"Functions","title":"Monstera.Newick.string","text":"Newick.string(tree, <keyword arguments or writer settings object>)\nNewick.string(node, <keyword arguments or writer settings object>)\nNewick.string(branch => node, <keyword arguments or writer settings object>)\n\nReturn a string with the Newick representation of a tree.\n\nThe string format can be optionally customised by passing a WriterSettings object, or with  the keyword arguments below.\n\nSee also Newick.read, Newick.WriterSettings\n\nArguments\n\nbrlength::Bool=true: whether to write branch lengths\nlabel_quote::Bool=false: wheteher to write double quote marks around node labels\nbrlength_digits::Int=308: branch lengths will be rounded to this number\nskip_nanlength::Bool=false: whether to write the length of a branch when it is NaN\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.Newick.write","page":"Functions","title":"Monstera.Newick.write","text":"Newick.write(<file name or io>, tree, <keyword arguments or writer settings object>)\nNewick.write(<file name or io>, node, <keyword arguments or writer settings object>)\nNewick.write(<file name or io>, branch => node, <keyword arguments or writer settings object>)\n\nWrite the Newick representation of a tree to an IOBuffer or a file.\n\nThe Newick string format can be optionally customised by passing a NewickWriterSettings  object, or with the keyword arguments below.\n\nSee also Newick.string, Newick.WriterSettings\n\nArguments\n\nbrlength::Bool=true: whether to write branch lengths\nlabel_quote::Bool=false: wheteher to write double quote marks around node labels\nbrlength_digits::Int=308: branch lengths will be rounded to thisnumber\nskip_nanlength::Bool=false: whether to write the length of a branch when it is NaN\n\nWriting to file\n\nappend=false: whether to append to the file\nlock=true: lock operations for safe multi-threaded access.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.Newick.WriterSettings","page":"Functions","title":"Monstera.Newick.WriterSettings","text":"Newick.WriterSettings(args)\n\nSettings for writing Newick strings.\n\nArguments\n\nbrlength::Bool=true: whether to write branch lengths\nlabel_quote::Bool=false: wheteher to write double quote marks around node labels\nbrlength_digits::Int=308: branch lengths will be rounded to this number of digits\nskip_nanlength::Bool=true: whether to write the length of a branch when it is NaN\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Monstera.Newick.ReaderSettings","page":"Functions","title":"Monstera.Newick.ReaderSettings","text":"Newick.ReaderSettings(taxonset = TaxonSet(); taxafrom=:outer)\n\nSettings for reading Newick strings.\n\nNode labels can be interpreted as taxon names. Taxon names will be mapped to the  corresponding taxon in the taxon set, or added to the taxon set if they were not already  present.\n\nThe taxafrom keyword argument is used to customise which node labels will be interpeted as taxon names, with any of the following values:\n\n:outer (default) only outer nodes\n:inner only inner nodes\n:all all nodes\n:none no nodes\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Branches-and-nodes","page":"Functions","title":"Branches and nodes","text":"","category":"section"},{"location":"docstrings/","page":"Functions","title":"Functions","text":"neighbours\nchildren\nisinner\nisouter\nnodes_flanking\nbranch_between\nhasparent\nparent\nlink!\nunlink!\ngraft!","category":"page"},{"location":"docstrings/#Monstera.neighbours","page":"Functions","title":"Monstera.neighbours","text":"neighbours(node) -> iterator\n\nReturn an iterator of the branches and nodes that are connected to a given node.\n\nSee also children.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.children","page":"Functions","title":"Monstera.children","text":"children(branch => node) -> iterator\nchildren(node) -> iterator\n\nReturn an iterator of the branches and nodes that are children of a node.\n\nSee also neighbours.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.isinner","page":"Functions","title":"Monstera.isinner","text":"isinner(node) -> Bool\n\nCheck whether a node is inner (a.k.a. \"internal\").\n\nInner nodes have a degree of 2 or greater.\n\nSee also isouter.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.isouter","page":"Functions","title":"Monstera.isouter","text":"isouter(node) -> Bool\n\nCheck whether a node is outer (a.k.a. \"external\", \"tip\", or \"leaf\").\n\nOuter nodes always have a degree of 1. This can include the tree root and isolated nodes.\n\nSee also isinner.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.nodes_flanking","page":"Functions","title":"Monstera.nodes_flanking","text":"nodes_flanking(branch)\n\nReturn a tuple with the nodes connected to a branch.\n\nWhen nodes are missing from one side of the branch, nothing will take their place in the tuple.\n\nSee also branch_between.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.branch_between","page":"Functions","title":"Monstera.branch_between","text":"branch_between(node1, node2)\n\nReturn the branch that connects node1 to node2.\n\nSee also nodes_flanking.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.hasparent","page":"Functions","title":"Monstera.hasparent","text":"hasparent(node)\n\nCheck whether a node has a parent.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Base.parent","page":"Functions","title":"Base.parent","text":"parent(A)\n\nReturn the underlying \"parent array”. This parent array of objects of types SubArray, ReshapedArray or LinearAlgebra.Transpose is what was passed as an argument to view, reshape, transpose, etc. during object creation. If the input is not a wrapped object, return the input itself. If the input is wrapped multiple times, only the outermost wrapper will be removed.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> V = view(A, 1:2, :)\n2×2 view(::Matrix{Int64}, 1:2, :) with eltype Int64:\n 1  2\n 3  4\n\njulia> parent(V)\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\n\n\n\n\nparent(node)\nparent(branch => node)\n\nReturn the parent of a node.\n\nThrows an error if the node has no parent.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.link!","page":"Functions","title":"Monstera.link!","text":"link!(node1, branch, node2)\n\nConnect node1 to node2 through a branch.\n\nLinking order is left-to-right, so that node1 is connected on the left side of the branch and node2 is connected on the right side of the branch. The new link is added to the tail of the link list of each node.\n\nThe graft! function can also be used to link nodes without need to pass a branch object.\n\nSee also graft! and unlink!\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.unlink!","page":"Functions","title":"Monstera.unlink!","text":"unlink!(branch, node) unlink!(branch => node)\n\nDisconnect a branch from a node.\n\nSee also link!\n\n\n\n\n\nunlink!(node1, node2) -> Branch\n\nDisconnect node1 from node2 and return the branch that was between them.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.graft!","page":"Functions","title":"Monstera.graft!","text":"graft!(tree, graft_node, receiver_node, brlength=NaN)\ngraft!(tree, graft_node, receiver_branch, newinner=false)\n\nGraft a node (and the subtree to which it is connected) on a receiver branch or node.\n\nReturns nothing, or a new branch-node pair when the newinner option is used (see below).\n\nGrafting on a node\n\nTo graft a node on another node is to link the two with a new branch. The length of the  new branch can be set with the brlength argument. The function returns the new branch.\n\nGrafting on a branch\n\nSay that you have a branch br1 (1, in the figure below), connected to nodes a and d. To graft a node g directly on branch br1 means that g is placed in between a and d, which results in the creation of a new branch (2, in the figure below). The function  returns nothing.\n\n\n      (a)              (e)                                   (a)                     (e)                    \n        \\              /                                       \\                     /                      \n         \\            /                                         \\                   /                       \n          \\          /                                           \\                 /                        \n           \\        /            `graft!(tree, g, br1)`           \\               /                         \n(g)        (a)----(d)         -------------------------->         (a)----(g)----(d)                         \n           /   1    \\                                             /   1      2    \\                         \n          /          \\                                           /                 \\                        \n         /            \\                                         /                   \\                       \n        /              \\                                       /                     \\                      \n      (c)              (f)                                   (c)                     (f)\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Bipartitions","page":"Functions","title":"Bipartitions","text":"","category":"section"},{"location":"docstrings/","page":"Functions","title":"Functions","text":"TaxonBipartition\nbipartitions\nis_singleton\nare_compatible\nbipartition_table","category":"page"},{"location":"docstrings/#Monstera.TaxonBipartition","page":"Functions","title":"Monstera.TaxonBipartition","text":"TaxonBipartition\n\nBit-vector that tags taxa in a list as belonging to one of two disjoint groups.\n\nBeware that many functions assume that bipartitions are normalised so that the first bit is always naught (see Penny & Hendy 1985).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Monstera.bipartitions","page":"Functions","title":"Monstera.bipartitions","text":"bipartitions(tree, singletons=true)\n\nReturn a list of taxon bipartitions corresponding to the branches of a tree.\n\nThe tree and its nodes must be associated to a taxon set. Singleton bipartitions are  excluded by default.\n\nThe returned list is of type TaxonBipartitionList. It is possible to retrieve the  bipartition corresponding to a branch with the bybranch property.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.is_singleton","page":"Functions","title":"Monstera.is_singleton","text":"is_singleton(bipartition)\n\nReturn true is the bipartition contains a singleton, i.e. it separates a single taxon from all the rest.\n\nIn other words, a singleton represents a taxon at a leaf node of a tree. This kind of bipartition is commonly called \"trivial\", because they provide no additional information about tree topology if one knows that every taxon is a leaf node. But singleton bipartitions     are not \"trivial\" in trees with sampled ancestors.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.are_compatible","page":"Functions","title":"Monstera.are_compatible","text":"are_compatible(bipartition1, bipartition2)\n\nCheck compatibility between two partitions.\n\nTwo bipartitions B1 and B2 are compatible if it is logically possible for them to exist in  the same tree.\n\nThis can be verified with one of the following conditions being true:\n\nB1 = B1 ∪ B2\nB1 = B1 ∪ ¬B2\n¬B1 = ¬B1 ∪ B2\n¬B1 = ¬B1 ∪ ¬B2\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.bipartition_table","page":"Functions","title":"Monstera.bipartition_table","text":"bipartition_table(trees, trim=true)\n\nReturn a record of the incidences of bipartitions in a collection of trees.\n\nThe bipartition table contains a matrix where the rows represent unique bipartitions and the columns represent trees. The entries of the matrix are true when a bipartition occurs in a tree. The matrix can be accessed by indexing the table either by bipartition or by tree  index (multiple indices and ranges are not supported yet).\n\nA number of entries are pre-allocated based on a guess of how many unique biparitions may be in the collection. There are removed by default (trim=true).\n\nProperties\n\n(Accessable through the dot-syntax)\n\nbipartitions: The list of unique bipartitions\nfrequencies: The number of times each bipartition occurs in a tree\nn: The number of trees\nm: The number of unique bipartitions\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Tree-distances","page":"Functions","title":"Tree distances","text":"","category":"section"},{"location":"docstrings/","page":"Functions","title":"Functions","text":"distance","category":"page"},{"location":"docstrings/#Monstera.distance","page":"Functions","title":"Monstera.distance","text":"distance(trees, mode = :ci; <keyword arguments>)\ndistance(tree1, tree2, mode = :ci; <keyword arguments>)\n\nReturn the distance between two trees or a the upper triangle of the matrix of pairwise  distances among trees in a collection.\n\nTwo distances are available through the mode argument: Clustering Information Distance  (:ci) (Smith 2020) and Robinson-Foulds (:rf) (Robinson & Foulds 1981).\n\nIt is assumed that all trees belong to a same taxon set and have the same taxa among them,  that the trees are unrooted, and that polytomies are hard.\n\nKeyword arguments\n\nsingletons=false: if true, singleton bipartitions (corresponding to outer branches) are considered when computing the distances. This deviates from the original definitions ofthe distances, but might be useful for trees with taxa in inner nodes (\"sampled ancestors\").\n\nFor Clustering Information Distance (:ci mode)\n\ndiffonly=true: if true, the distance is computed only from the bipartitions that are not shared between the two trees. This makes small distances more accurate and faster to compute.\n\n\n\n\n\n","category":"function"}]
}
