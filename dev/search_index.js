var documenterSearchIndex = {"docs":
[{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Tree data structures must implement their own types for trees, nodes, and branches, which ought to be subtypes of AbstractTree, AbstractNode, and AbstractBranch, respectively. As an example, let's call them MyTree, MyNode, and MyBranch.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"struct MyBranch <: AbstractBranch\n    # ...<Implementation details>...\nend\n\nstruct MyNode <: AbstractNode\n    # ...<Implementation details>...\nend\n\nstruct MyTree <: AbstractTree\n    # ...<Implementation details>...\nend","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The Monstera interface requires us to indicate that those types match each other by implementing the following methods:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"treetype(::Type{MyNode}) = MyTree\ntreetype(::Type{MyBranch}) = MyTree\n\nnodetype(::Type{MyTree}) = MyNode\nnodetype(::Type{MyBranch}) = MyNode\n\nbranchtype(::Type{MyTree}) = MyBranch\nbranchtype(::Type{MyNode}) = MyBranch","category":"page"},{"location":"interface/#Node-types","page":"Interface","title":"Node types","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Required public properties Default value Description User settable\nid::PhyloInd 0 (should be set at tree construction) Numerical identifier of the node No\ntaxon::PhyloInd 0 (= no taxon) Numerical identifier of the taxon associated to the node Yes\nlabel::String \"\" Label for display Yes","category":"page"},{"location":"interface/#Branch-types","page":"Interface","title":"Branch types","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Required public properties Default value Description User settable\nid::PhyloInd 0 (should be set at tree construction) Numerical identifier of the branch No\nlength::Float64 NaN Length of the branch Yes","category":"page"},{"location":"interface/#Tree-types","page":"Interface","title":"Tree types","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Required public properties Default value Description User settable\ntaxonset::Union{Nothing,TaxonSet} nothing Set of taxa represented in the tree Yes\nroot::Union{Nothing,MyNode} nothing Access point to the tree Yes\nnodes - Collection with settable indices listing all the nodes associated to the tree No\nbranches - Collection with settable indices listing all the branches associated to the tree No","category":"page"},{"location":"interface/#Mandatory-methods","page":"Interface","title":"Mandatory methods","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Mandatory methods pertaining to the interconnections among branches and nodes follow a.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Required methods Brief description\nneighbours(node) Return a branch => node iterator of the neighbours of a node\nchildren(branch => node) Return a branch => node iterator of the children of node as seen coming from branch\nhasparent(node) Check whether the node as an intrinsic parent\nparent(branch => node) Return the parent of a node, as seen coming  from branch\nnodes_flanking(branch) Return a tuple with the nodes connected to a branch\nlink!(node1, branch, node2) Link two nodes through a branch, in left-to-right direction\nunlink!(node1, node2) Unlink two nodes and return the branch that was connecting them","category":"page"},{"location":"#Monstera.jl-Documentation","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"","category":"section"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"CurrentModule = Monstera","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"This is an experimental package for phylogenetics in Julia.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"These are the main objectives of this package:","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Provide a general interface for basic operations with phylogenetic trees, allowing the ","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"experimentation with a variety of data structures to represent trees","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Allow as much flexibility as possible:\nTaxa can live in inner or outer nodes\nNon-splitting nodes are permitted\nBe ergonomic for interactive use","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Only one base tree type is available for now: RoundaboutTree (see below).","category":"page"},{"location":"#Quick-Introduction","page":"Monstera.jl Documentation","title":"Quick Introduction","text":"","category":"section"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Let's start off loading a tree in Newick format. This is a little extract of the tree of the Araceae from Haigh et al. (2022): ","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> philo_string = \"(((Philodendron,Adelonema),(Homalomena,Furtadoa)),(Cercestis,Culcasia),Monstera);\";\n","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"We can create a tree object from that string using the Newick.parse method, and specifying the tree type that we want. Only one tree type is available for now: RoundaboutTree. Optionally, we can create a TaxonSet from the labels of the tree.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> philo_tree = Newick.parse(RoundaboutTree, philo_string, TaxonSet())\nRoundaboutTree: 12 nodes, 11 branches","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Let's take a look at it. The textplot function will print a diagram of the tree:","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> textplot(philo_tree)\n             ┌───────●(4)Philodendron\n     ┌───────○(3)\n     │       └───────●(5)Adelonema\n┌────○(2)\n│    │       ┌───────●(7)Homalomena\n│    └───────○(6)\n│            └───────●(8)Furtadoa\n○(1)\n│    ┌───────●(10)Cercestis\n├────○(9)\n│    └───────●(11)Culcasia\n│\n└────●(12)Monstera","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Nodes are represented by small circles, with numerical identifiers in parentheses. Next to that, node labels are shown. Nodes are objects, and they can be retrieved from the tree by their IDs. For instance, let's take a look at nodes #3 and #4, and their main properties.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> philo_tree.nodes[3]\nRoundaboutNode #3 (no taxon)\njulia> philo_tree.nodes[3].id\n3\njulia> philo_tree.nodes[3].taxon\n0\njulia> philo_tree.nodes[3].label\n\"\"\njulia> philo_tree.nodes[4]\nRoundaboutNode #4 (taxon 1) - \"Philodendron\"\njulia> philo_tree.nodes[4].id\n4\njulia> philo_tree.nodes[4].taxon\n1\njulia> philo_tree.nodes[4].label\n\"Philodendron\"","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Nodes can be associated to a taxon with its own numeric ID in a TaxonSet, or have no taxon (interally represented with a 0). Also, the diagram from textplot represents nodes with  taxa as filled circles. The taxon set is property of the tree, accessible as philo_tree.taxonset. A single taxon set object is shared with groups of trees that represent the same group of taxa.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Branches are have IDs, like nodes, and are accessible with the branches property.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> philo_tree.branches\n11-element Vector{RoundaboutBranch}:\n RoundaboutBranch #1: 1 ○⎯⎯⎯○ 2 (length NaN)\n RoundaboutBranch #2: 2 ○⎯⎯⎯○ 3 (length NaN)\n RoundaboutBranch #3: 3 ○⎯⎯⎯● 4 (length NaN)\n RoundaboutBranch #4: 3 ○⎯⎯⎯● 5 (length NaN)\n RoundaboutBranch #5: 2 ○⎯⎯⎯○ 6 (length NaN)\n RoundaboutBranch #6: 6 ○⎯⎯⎯● 7 (length NaN)\n RoundaboutBranch #7: 6 ○⎯⎯⎯● 8 (length NaN)\n RoundaboutBranch #8: 1 ○⎯⎯⎯○ 9 (length NaN)\n RoundaboutBranch #9: 9 ○⎯⎯⎯● 10 (length NaN)\n RoundaboutBranch #10: 9 ○⎯⎯⎯● 11 (length NaN)\n RoundaboutBranch #11: 1 ○⎯⎯⎯● 12 (length NaN)","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Little diagrams of the branches show the nodes to which they are attached. We have no branch lengths in this example, so the \"length\" value is set to NaN.","category":"page"},{"location":"#Orientation-conventions-and-the-branch-node-notation","page":"Monstera.jl Documentation","title":"Orientation conventions and the branch => node notation","text":"","category":"section"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"This is a central concept in the Monstera package. Tree objects can have an intrinsic  orientation, so that branches are directed outward from the root node. Monstera also makes  it possible to traverse the tree in any arbitrary direction by means of special conventions  in function calls. For instance, if we have a function f that traverses a tree, or a  sub-tree of a tree, we can call f in a number of ways to indicate exactly what part of the  tree to traverse, and in what direction:","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Notation Meaning\nf(tree) Traverse the entire tree starting from its root node\nf(node) Traverse the part of the tree that descends from a node, following to the intrinsic orientation of the tree\nf(nothing => node) Traverse the entire tree as if it were rooted on a node\nf(branch => node) Traverse the part of the tree that descends from a node, with the parent-child direction indicated by the branch-node pair","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"The textplot function is one of the many functions that work in this way. It prints a  diagram of the tree, or a sub-tree, using characters on a terminal window.  Let's see it in  action. First, we create a tree from a Newick string, and we plot it with  textplot(tree). The tree is plotted from left to right, from its root node.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> tree = Newick.parse(RoundaboutTree, \"(((A,B),C),(D,E),H);\");\n\njulia> textplot(tree)\n             ┌───────○(4)A\n     ┌───────○(3)\n┌────○(2)    └───────○(5)B\n│    │\n│    └───────○(6)C\n│\n○(1) ┌───────○(8)D\n├────○(7)\n│    └───────○(9)E\n│\n└────○(10)H","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"As node #1 is the root node, textplot(tree.nodes[1]) or textplot(tree.root) produces an  identical result.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> textplot(tree.nodes[1])\n             ┌───────○(4)A\n     ┌───────○(3)\n┌────○(2)    └───────○(5)B\n│    │\n│    └───────○(6)C\n│\n○(1) ┌───────○(8)D\n├────○(7)\n│    └───────○(9)E\n│\n└────○(10)H","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"If we do the same with node #2 instead, we get the corresponding sub-tree.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> textplot(tree.nodes[2])\n     ┌───────○(4)A\n┌────○(3)\n○(2) └───────○(5)B\n│\n└────○(6)C","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"The branch => node notation gives us a more flexible way to plot sub-trees, but we need to know which branches are connecting which nodes. We get the information we need just by  showing the branch list on the REPL.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> tree.branches\n9-element Vector{RoundaboutBranch}:\n RoundaboutBranch #1: 1 ○⎯⎯⎯○ 2 (length NaN)\n RoundaboutBranch #2: 2 ○⎯⎯⎯○ 3 (length NaN)\n RoundaboutBranch #3: 3 ○⎯⎯⎯○ 4 (length NaN)\n RoundaboutBranch #4: 3 ○⎯⎯⎯○ 5 (length NaN)\n RoundaboutBranch #5: 2 ○⎯⎯⎯○ 6 (length NaN)\n RoundaboutBranch #6: 1 ○⎯⎯⎯○ 7 (length NaN)\n RoundaboutBranch #7: 7 ○⎯⎯⎯○ 8 (length NaN)\n RoundaboutBranch #8: 7 ○⎯⎯⎯○ 9 (length NaN)\n RoundaboutBranch #9: 1 ○⎯⎯⎯○ 10 (length NaN)","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Since branch #1 connects node #1 (the root) to node #2,  textplot(tree.branches[1] => tree.nodes[2]) will print the same sub-tree as in the  previous example.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> textplot(tree.branches[1] => tree.nodes[2])\n     ┌───────○(4)A\n┌────○(3)\n○(2) └───────○(5)B\n│\n└────○(6)C","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"With the branch => node notation, we can plot sub-trees with a completely different  orientation, without actually changing the root of the tree. The key is that we consider the given branch as coming from the parent of the node. Take a look at the following  example:","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> textplot(tree.branches[2] => tree.nodes[2])\n┌────○(6)C\n│\n○(2)         ┌───────○(8)D\n│    ┌───────○(7)\n└────○(1)    └───────○(9)E\n     │\n     └───────○(10)H","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Branch #2 connects node #2 to node #3, so we are in effect plotting the sub-tree of node #2 as though node #3 were its parent. Hence, node #1, the true root of the tree, appears as a descendant of node #2, and node #3 is left out.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"The branch => node notation also gives us the ability to plot the entire tree as though  any node were the root of the tree. Since a \"proper\" root node has no parent, we replace the branch with nothing, like so:","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> textplot(nothing => tree.nodes[2])\n     ┌───────○(4)A\n┌────○(3)\n│    └───────○(5)B\n│\n○(2)─○(6)C\n│\n│            ┌───────○(8)D\n│    ┌───────○(7)\n└────○(1)    └───────○(9)E\n     │\n     └───────○(10)H","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"The usefulness of having all these options for defining tree orientations might not be  obvious in common use cases, but it has practical value. For instance, in many cases the root of the tree might not be biologically meaningful, such as in trees inferred by  maximum-likelihood without an explicit outgroup.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Also, some important algorithms require  treating any arbitrary node as the root of the tree, as in maximum-likelihood branch length  optimisation.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Finally, the branch => node notation also a useful return value of many functions. The children function, for instance, returns an iterator of branch => node  pairs: instead of just listing the children nodes, we get the corresponding branch and node of each child.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"julia> collect(children(tree.branches[2] => tree.nodes[2]))\n2-element Vector{Pair{RoundaboutBranch{RoundaboutNode}, RoundaboutNode}}:\n RoundaboutBranch #5 => RoundaboutNode #6 (no taxon) - \"C\"\n RoundaboutBranch #1 => RoundaboutNode #1 (no taxon)","category":"page"},{"location":"#The-RoundaboutTree-type","page":"Monstera.jl Documentation","title":"The RoundaboutTree type","text":"","category":"section"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"This type implements a complex data structure based on circular linked lists of branches  surrounding nodes: \"roundabouts\" of branches. The use of linked lists makes the construction  and modification of trees very fast, as it avoids allocations associated to array-based   lists. This comes at the cost of complexity and indirections that slow down tree   traversals.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Each RoundaboutBranch object has a \"left\" and \"right\" side. They correspond to the  \"parent\" and \"child\" sides of the branch, following the orientation in which the tree was  constructed, for instance, from a Newick string.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Each side of a branch contain fields with the following information:","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"A reference to the RoundaboutNode connected by this side, or nothing if there is no node yet (this should only happen in intermediate stages of tree construction or branch swapping)\nA reference to the next RoundaboutBranch connected to this side's node. If there are no","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"other branches, this field points back to the present branch.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"An instance of the side type of the next RoundaboutBranch which is connected to this side's node.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"Side types are RoundaboutLeft, RoundaboutRight and RoundaboutNoSide; subtypes of RoundaboutSide.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"The RoundaboutNode objects contain a reference to the last RoundaboutBranch that was connected to them. This provides quick access to both the head and tail of the circular  list.","category":"page"},{"location":"","page":"Monstera.jl Documentation","title":"Monstera.jl Documentation","text":"The RoundaboutTree data structure is a spin on Felsenstein's nodelet-based tree data  structure (Felsenstein 2004), used in PHYLIP and in the Phylogenetic Likelihood Library used by RAxML-NG. I replaced the pairs of \"nodelets\" pointing back to each other with single  branches that contain two sides. I also made nodes concrete objects, insetad of emerging  properties of cycles of nodelets. The advantage is that this structure fits a generic tree  interface better, and it is conceptually simpler and easier to use in interactive  programming.","category":"page"},{"location":"docstrings/","page":"-","title":"-","text":"Modules = [Monstera, Monstera.Newick]\nOrder   = [:function, :type]","category":"page"},{"location":"docstrings/#Base.get-Tuple{TaxonSet, String}","page":"-","title":"Base.get","text":"get(taxonset, name)\n\nGet the taxon ID that matches a name in a taxon set, or return 0 if there is no match.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.haskey-Tuple{TaxonSet, String}","page":"-","title":"Base.haskey","text":"hasname(taxonset, name)\n\nCheck whether a taxon set contains a name.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.keys-Tuple{TaxonSet}","page":"-","title":"Base.keys","text":"names(taxonset)\n\nReturn the list of names of taxa in a taxon set.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.parent-Tuple{AbstractNode}","page":"-","title":"Base.parent","text":"parent(node)\nparent(branch => node)\n\nReturn the parent of a node.\n\nThrows an error if the node has no parent.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.print-Tuple{IO, TaxonBipartition}","page":"-","title":"Base.print","text":"Print taxon bipartition grouping taxa by 5\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.setindex!-Tuple{Monstera.CharCanvas, Char, Any, Any}","page":"-","title":"Base.setindex!","text":"Draw on a canvas. Points outside the canvas will be ignored.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.size-Tuple{AbstractTree}","page":"-","title":"Base.size","text":"size(tree)\n\nReturn the number of branches and nodes in a tree.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera._clustering_entropy","page":"-","title":"Monstera._clustering_entropy","text":"Return H * n\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera._mutual_clustering_information","page":"-","title":"Monstera._mutual_clustering_information","text":"Return s * n\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.add!-Tuple{TaxonSet, Vararg{String}}","page":"-","title":"Monstera.add!","text":"add!(taxonset, names...)\n\nAdd name(s) to a taxon set and return its id.\n\nNames already in the taxon set will be ignored (skipped or return 0).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.are_compatible-Tuple{TaxonBipartition, TaxonBipartition}","page":"-","title":"Monstera.are_compatible","text":"are_compatible(bipartition1, bipartition2)\n\nCheck compatibility between two partitions.\n\nTwo bipartitions B1 and B2 are compatible if it is logically possible for them to exist in  the same tree.\n\nThis can be verified with one of the following conditions being true:\n\nB1 = B1 ∪ B2\nB1 = B1 ∪ ¬B2\n¬B1 = ¬B1 ∪ B2\n¬B1 = ¬B1 ∪ ¬B2\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.bipartition_table","page":"-","title":"Monstera.bipartition_table","text":"bipartition_table(trees, trim=true)\n\nReturn a record of the incidences of bipartitions in a collection of trees.\n\nThe bipartition table contains a matrix where the rows represent unique bipartitions and the columns represent trees. The entries of the matrix are true when a bipartition occurs in a tree. The matrix can be accessed by indexing the table either by bipartition or by tree  index (multiple indices and ranges are not supported yet).\n\nA number of entries are pre-allocated based on a guess of how many unique biparitions may be in the collection. There are removed by default (trim=true).\n\nProperties\n\n(Accessable through the dot-syntax)\n\nbipartitions: The list of unique bipartitions\nfrequencies: The number of times each bipartition occurs in a tree\nn: The number of trees\nm: The number of unique bipartitions\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.bipartitions-Tuple{AbstractTree}","page":"-","title":"Monstera.bipartitions","text":"bipartitions(tree, singletons=true)\n\nReturn a list of taxon bipartitions corresponding to the branches of a tree.\n\nThe tree and its nodes must be associated to a taxon set. Singleton bipartitions are  excluded by default.\n\nThe returned list is of type TaxonBipartitionList. It is possible to retrieve the  bipartition corresponding to a branch with the bybranch property.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.branch_between-Tuple{AbstractNode, AbstractNode}","page":"-","title":"Monstera.branch_between","text":"branch_between(node1, node2)\n\nReturn the branch that connects node1 to node2.\n\nSee also nodes_flanking.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.branchtype","page":"-","title":"Monstera.branchtype","text":"treetype(x) -> type <: AbstractTree\nnodetype(x) -> type <: AbstractNode\nbranchtype(x) -> type <: AbstractBranch\n\nReturn the node, branch, or tree type that matches another type.\n\nThis is an auxiliary function used to select matching types in constructors.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.children-Tuple{Pair{<:AbstractBranch, <:AbstractNode}}","page":"-","title":"Monstera.children","text":"children(branch => node) -> iterator\nchildren(node) -> iterator\n\nReturn an iterator of the branches and nodes that are children of a node.\n\nSee also neighbours.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.cladesize","page":"-","title":"Monstera.cladesize","text":"cladesize(branch => node, outer=false)\ncladesize(node, outer=false)\ncladesize(tree, outer=false)\n\nReturn the number of nodes in a clade, optionally counting only the outer nodes.\n\nThe clade size of a tree is computed from the tree's root. Unlike the size function, cladesize counts that are directly or indirectly connected to the root.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.cleanup!","page":"-","title":"Monstera.cleanup!","text":"cleanup!(tree)\n\nRemove unconnected nodes and branches and re-index the connected elements.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.clone-Tuple{T} where T<:AbstractTree","page":"-","title":"Monstera.clone","text":"clone(tree)\n\nCreate a copy of a tree.\n\nThe copied tree has the same topology and properites, but its contents are fully  independent. Only the taxon set is shared between the original tree and the clone.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.clustering_entropy","page":"-","title":"Monstera.clustering_entropy","text":"clustering_entropy(bipartition, n=length(bipartition))\n\nReturn the entropy associated to a taxon bipartition as given by the formula from Smith 2020:\n\nH = (-An) * log₂(An) - (Bn) * log₂(Bn)\n\nWhere A and B represent the sizes of each bipartition and n represents the total number of taxa.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.collapse!-Tuple{AbstractTree, Pair{<:AbstractBranch, <:AbstractNode}}","page":"-","title":"Monstera.collapse!","text":"collapse!(tree, branch => node)\n\nEliminate a branch and node in the tree, and reconnect their children to their parent.\n\nIn the example below, we collapse branch \"1\" and node \"b\".\n\n(c)       (d)                                      \\       /                                         \\     /                                          3\\  4/                        (c)  (d)  (e)        \\ /                           \\   |   /          (b)       (e)                  \\ 4|  /             \\       /                    3\\ |2/               \\     /      ––––>        \\|/                1\\  2/                        (a)                  \\ /                          |                   (a)                          |                    |                           |                    |                           ⃨                    |                                                ⃨                                 \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.count_symdiff-Tuple{Any, Any}","page":"-","title":"Monstera.count_symdiff","text":"count_symdiff(v1, v2)\n\nCount the number of elements that two integer vectors do not have in common.\n\nZeros are ignored.\n\nAssumptions\n\nVectors of equal size\nVectors ordered from greatest to smallest\nElements are unique within vectors\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.distance","page":"-","title":"Monstera.distance","text":"distance(trees, mode = :ci; <keyword arguments>)\ndistance(tree1, tree2, mode = :ci; <keyword arguments>)\n\nReturn the distance between two trees or a matrix of pairwise distances between trees in a  collection.\n\nTwo distances are available through the mode argument: Clustering Information Distance  (:ci) (Smith 2020) and Robinson-Foulds (:rf) (Robinson & Foulds 1981).\n\nIt is assumed that all trees belong to a same taxon set and have the same taxa among them,  that the trees are unrooted, and that polytomies are hard.\n\nKeyword arguments\n\nsingletons=false: if true, singleton bipartitions (corresponding to outer branches) are considered when computing the distances. This deviates from the original definitions ofthe distances, but might be useful for trees with taxa in inner nodes (\"sampled ancestors\").\n\nFor Clustering Information Distance (:ci mode)\n\ndiffonly=true: if true, the distance is computed only from the bipartitions that are not shared between the two trees. This makes small distances more accurate and faster to compute.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.fast_symdiff-Tuple{Any, Any}","page":"-","title":"Monstera.fast_symdiff","text":"fast_symdiff(v1, v2)\n\nReturn the symmetric difference between two vectors of integers.\n\nZeros are ignored.\n\nThis is not general-purpose alternative to symdiff.\n\nAssumptions\n\nVectors of equal size\nVectors ordered from greatest to smallest\nElements are unique within vectors\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.find_best_assignment-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Bool}} where T","page":"-","title":"Monstera.find_best_assignment","text":"findbestassignment(C, maximize=false) = solution\n\nSolve the two-dimensional assignment problem with a rectangular cost matrix C,  scanning row-wise.\n\nNote that cost returned can overflow if using smaller integer types\n\nExample\n\njulia> M=rand(1:100,3,4)\n3×4 Matrix{Int64}:\n 77  51  42  67\n 72  53  47   4\n 24  50  77  96\n\n julia> sol = find_best_assignment(M)\n AssignmentSolution(CartesianIndex.(1:3, [3, 4, 1]), 70)\n \n julia> sum(M[sol])\n 70\n \n julia> max_sol = find_best_assignment(M', true)\n AssignmentSolution(CartesianIndex.([1, 2, 4], 1:3), 226)\n\nThis code is a port of Matlab code released [1] in the public domain by the US Naval Research Laboratory. \n\nThis work is not affliated with or endorsed by the US Naval Research Laboratory.\n\nThe algorithm is described in detail in [2].\n\nREFERENCES: [1] D. F. Crouse, \"The Tracker Component Library: Free Routines for Rapid     Prototyping,\" IEEE Aerospace and Electronic Systems Magazine, vol. 32,     no. 5, pp. 18-27, May. 2017 [2] D. F. Crouse, \"Advances in displaying uncertain estimates of multiple    targets,\" in Proceedings of SPIE: Signal Processing, Sensor Fusion, and    Target Recognition XXII, vol. 8745, Baltimore, MD, Apr. 2013\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.find_path-Union{Tuple{N}, Tuple{N, N}} where N<:AbstractNode","page":"-","title":"Monstera.find_path","text":"find_path(node1, node2)\n\nFind the path from node1 to node2 in a tree.\n\nReturns a tuple with the path as a vector of nodes and a vector of branches. Raises an error if no path is found.\n\nExamples\n\njulia> tree = Newick.parse(RoundaboutTree, \"((5,2),((4,1),3));\");\n\n# julia> textplot(tree, outerlabels=false)\n#      ┌───────○(3)\n# ┌────○(2)\n# │    └───────○(4)\n# ○(1)\n# │            ┌───────○(7)\n# │    ┌───────○(6)\n# └────○(5)    └───────○(8)\n#      │\n#      └───────○(9)\n\n# Find the path between node 4 and node 6\n\njulia> path_nodes, path_branches = find_path(tree.nodes[4], tree.nodes[6]);\n\njulia> path_nodes\n5-element Vector{RoundaboutNode}:\n RoundaboutNode #4 (no taxon) - \"2\"\n RoundaboutNode #2 (no taxon)\n RoundaboutNode #1 (no taxon)\n RoundaboutNode #5 (no taxon)\n RoundaboutNode #6 (no taxon)\n\njulia> path_branches\n4-element Vector{RoundaboutBranch}:\n RoundaboutBranch #3: 2 ○⎯⎯⎯○ 4 (length NaN)\n RoundaboutBranch #1: 1 ○⎯⎯⎯○ 2 (length NaN)\n RoundaboutBranch #4: 1 ○⎯⎯⎯○ 5 (length NaN)\n RoundaboutBranch #5: 5 ○⎯⎯⎯○ 6 (length NaN)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.find_prev_and_next_branches-Tuple{RoundaboutBranch, Monstera.RoundaboutSide}","page":"-","title":"Monstera.find_prev_and_next_branches","text":"Return the next branch and side, and the previous branch and side in a branch cycle\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.get_link_fields-Tuple{RoundaboutBranch, Monstera.RoundaboutLeft}","page":"-","title":"Monstera.get_link_fields","text":"Return the fields of a branch necessary to move on to the next branch on the left or right side.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.getnode-Tuple{RoundaboutBranch, Monstera.RoundaboutLeft}","page":"-","title":"Monstera.getnode","text":"Return the node that is connected to a given side of the branch\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.getside-Tuple{RoundaboutBranch, RoundaboutNode}","page":"-","title":"Monstera.getside","text":"Return the side of the branch (left, right or no side) that is connected to the node.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.graft!","page":"-","title":"Monstera.graft!","text":"graft!(tree, graft_node, receiver_node, brlength=NaN)\ngraft!(tree, graft_node, receiver_branch, newinner=false)\n\nGraft a node (and the subtree to which it is connected) on a receiver branch or node.\n\nReturns nothing, or a new branch-node pair when the newinner option is used (see below).\n\nGrafting on a node\n\nTo graft a node on another node is to link the two with a new branch. The length of the  new branch can be set with the brlength argument. The function returns the new branch.\n\nGrafting on a branch\n\nSay that you have a branch br1 (1, in the figure below), connected to nodes a and d. To graft a node g directly on branch br1 means that g is placed in between a and d, which results in the creation of a new branch (2, in the figure below). The function  returns nothing.\n\n\n      (a)              (e)                                   (a)                     (e)                    \n        \\              /                                       \\                     /                      \n         \\            /                                         \\                   /                       \n          \\          /                                           \\                 /                        \n           \\        /            `graft!(tree, g, br1)`           \\               /                         \n(g)        (a)----(d)         -------------------------->         (a)----(g)----(d)                         \n           /   1    \\                                             /   1      2    \\                         \n          /          \\                                           /                 \\                        \n         /            \\                                         /                   \\                       \n        /              \\                                       /                     \\                      \n      (c)              (f)                                   (c)                     (f)\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.hasparent-Tuple{Any}","page":"-","title":"Monstera.hasparent","text":"hasparent(node)\n\nCheck whether a node has a parent.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.highight!-Tuple{Monstera.CharCanvas, Any, Any}","page":"-","title":"Monstera.highight!","text":"Set coordinates in a canvas to appear highlighted (blinking + reversed).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.is_singleton-Tuple{TaxonBipartition}","page":"-","title":"Monstera.is_singleton","text":"is_singleton(bipartition)\n\nReturn true is the bipartition contains a singleton, i.e. it separates a single taxon from all the rest.\n\nIn other words, a singleton represents a taxon at a leaf node of a tree. This kind of bipartition is commonly called \"trivial\", because they provide no additional information about tree topology if one knows that every taxon is a leaf node. But singleton bipartitions     are not \"trivial\" in trees with sampled ancestors.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.isinner-Tuple{AbstractNode}","page":"-","title":"Monstera.isinner","text":"isinner(node) -> Bool\n\nCheck whether a node is inner (a.k.a. \"internal\").\n\nInner nodes have a degree of 2 or greater.\n\nSee also isouter.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.isouter-Tuple{AbstractNode}","page":"-","title":"Monstera.isouter","text":"isouter(node) -> Bool\n\nCheck whether a node is outer (a.k.a. \"external\", \"tip\", or \"leaf\").\n\nOuter nodes always have a degree of 1. This can include the tree root and isolated nodes.\n\nSee also isinner.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.key-Tuple{TaxonSet, Vararg{Any}}","page":"-","title":"Monstera.key","text":"key(taxonset, ids...)\n\nGet the names of the taxa with the given ids in the taxon set.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.link!-Tuple{AbstractNode, AbstractBranch, AbstractNode}","page":"-","title":"Monstera.link!","text":"link!(node1, branch, node2)\n\nConnect node1 to node2 through a branch.\n\nLinking order is left-to-right, so that node1 is connected on the left side of the branch and node2 is connected on the right side of the branch. The new link is added to the tail of the link list of each node.\n\nThe graft! function can also be used to link nodes without need to pass a branch object.\n\nSee also graft! and unlink!\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.mci_cost_matrix-Tuple{Any, Any, Any}","page":"-","title":"Monstera.mci_cost_matrix","text":"Return matrix with s * n value of each bipartition matching.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.mutual_clustering_information-Tuple{TaxonBipartition, TaxonBipartition}","page":"-","title":"Monstera.mutual_clustering_information","text":"mutual_clustering_information(bipartition1, bipartition2)\n\nReturn the mutual clustering information between two bipartitions.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.neighbours-Tuple{AbstractNode}","page":"-","title":"Monstera.neighbours","text":"neighbours(node) -> iterator\n\nReturn an iterator of the branches and nodes that are connected to a given node.\n\nSee also children.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.newbranch!-Tuple{AbstractTree, Any}","page":"-","title":"Monstera.newbranch!","text":"newnode!(tree, n=1)\nnewbranch!(tree, n=1)\n\nCreate and return n new branches or nodes in a tree.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.newnode!-Tuple{AbstractTree, Any}","page":"-","title":"Monstera.newnode!","text":"newnode!(tree, n=1)\nnewbranch!(tree, n=1)\n\nCreate and return n new branches or nodes in a tree.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.nodes_flanking-Tuple{AbstractBranch}","page":"-","title":"Monstera.nodes_flanking","text":"nodes_flanking(branch)\n\nReturn a tuple with the nodes connected to a branch.\n\nWhen nodes are missing from one side of the branch, nothing will take their place in the tuple.\n\nSee also branch_between.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.nodetype","page":"-","title":"Monstera.nodetype","text":"treetype(x) -> type <: AbstractTree\nnodetype(x) -> type <: AbstractNode\nbranchtype(x) -> type <: AbstractBranch\n\nReturn the node, branch, or tree type that matches another type.\n\nThis is an auxiliary function used to select matching types in constructors.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.normalise!-Tuple{Any}","page":"-","title":"Monstera.normalise!","text":"normalise!(bipartition)\n\nNormalise a bipartition so that the first bit is always naught (Penny & Hendy 1985)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.paint_white_background!-Tuple{Any, Any, Any}","page":"-","title":"Monstera.paint_white_background!","text":"Replace non-line break characters with from the left up to the x-th character at height y\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.pretraverse-Tuple{Function, Any}","page":"-","title":"Monstera.pretraverse","text":"pretraverse(f, tree)\npretraverse(f, branch => node)\npretraverse(f, node)\n\nTraverse a tree (or subtree) in preorder, calling the function f on each branch-node pair as they are visited.\n\nReturns the return value of the last call of f.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.prune!","page":"-","title":"Monstera.prune!","text":"prune!(branch1, node, branch2)\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.randtree","page":"-","title":"Monstera.randtree","text":"randtree(T, taxonset, rooted=true)\nrandtree(T, n, rooted=true)\n\nCreate a random binary tree of type T with the given taxon set, or the given number n of  outer nodes.\n\nIf rooted is false, the tree will be unrooted, i.e. it will have a basal trichotomy (this requires at least 3 outer nodes).\n\nRandom.seed!(1)\ntextplot(randtree(RoundaboutTree, 5, false))\n\n# output\n\n┌────○(2)\n│\n│    ┌───────○(5)\n○(1)─○(3)\n│    └───────○(6)\n│\n│    ┌───────○(7)\n└────○(4)\n     └───────○(8)\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.raw_bipartitions-Tuple{AbstractTree}","page":"-","title":"Monstera.raw_bipartitions","text":"raw_bipartitions(tree)\n\nReturn a the raw (=unnormalised) bipartitions of a tree, singletons included.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.swapnodes!-Tuple{Pair{<:AbstractBranch, <:AbstractNode}, Pair{<:AbstractBranch, <:AbstractNode}}","page":"-","title":"Monstera.swapnodes!","text":"swapnodes!(branch1 => node1, branch2 => node2) -> nothing\n\nExchange nodes between two pairs of nodes and branches.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.textplot-Tuple{IO, Any}","page":"-","title":"Monstera.textplot","text":"textplot([io::IO=stdout], tree; <keyword arguments>)\ntextplot([io::IO=stdout], node; <keyword arguments>)\ntextplot([io::IO=stdout], branch => node; <keyword arguments>)\n\nUse characters to plot a tree or subtree.\n\nWarning: Branch lengths are not respected!\n\nArguments\n\nids=true: Show the ids of the nodes (between parentheses).\nouterlabels=true: Show the labels of outer nodes.\ninnerlabels=false: Show the labels of inner nodes.\nhighlight=Int[]: Vector of nodes or node IDs that will appear highlighted in the plot.\n\nExamples\n\nnewick = \"((A,B)H,((C,D,E)I,(F)K)J)G;\"\ntree = Newick.parse(RoundaboutTree, newick, TaxonSet())\ntextplot(tree)\n\n# output\n\n     ┌───────●(3)A\n┌────○(2)\n│    └───────●(4)B\n│\n○(1)         ┌───────●(7)C\n│            │\n│    ┌───────○(6)────●(8)D\n│    │       │\n└────○(5)    └───────●(9)E\n     │\n     └───────○(10)────●(11)F\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.treetype","page":"-","title":"Monstera.treetype","text":"treetype(x) -> type <: AbstractTree\nnodetype(x) -> type <: AbstractNode\nbranchtype(x) -> type <: AbstractBranch\n\nReturn the node, branch, or tree type that matches another type.\n\nThis is an auxiliary function used to select matching types in constructors.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Monstera.two_way_setdiff-NTuple{4, Any}","page":"-","title":"Monstera.two_way_setdiff","text":"two_way_setdiff(v1, v2, result1, result2)\n\nCompute setdiff(v1, v2) and store it on result1, and compute setdiff(v2, v1) and store  it in result2\n\nReturns the indices of the last element stored in each result vector. Result vectors must be  of the same length as input vectors. Zeros are ignored.\n\nThis is not general-purpose alternative to symdiff.\n\nAssumptions\n\nVectors of equal size\nVectors ordered from greatest to smallest\nElements are unique within vectors\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.ungraft!-Tuple{AbstractTree, Pair{<:AbstractBranch, <:AbstractNode}}","page":"-","title":"Monstera.ungraft!","text":"ungraft!(tree, branch => node)\n\nSeparate a node with a branch from the rest of the tree without leaving other nodes  disconnected.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.unlink!-Tuple{AbstractBranch, AbstractNode}","page":"-","title":"Monstera.unlink!","text":"unlink!(branch, node) unlink!(branch => node)\n\nDisconnect a branch from a node.\n\nSee also link!\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.unlink!-Tuple{AbstractNode, AbstractNode}","page":"-","title":"Monstera.unlink!","text":"unlink!(node1, node2) -> Branch\n\nDisconnect node1 from node2 and return the branch that was between them.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.AbstractBranch","page":"-","title":"Monstera.AbstractBranch","text":"The AbstractBranch type is the supertype of branch types. Subtypes of AbstractBranch must implement the public properties listed below.\n\nPublic properties\n\nid: integer number that uniquely identifies a node in a tree. Not user-settable.\nlength: branch length as a Float64. Branches with NA values are considered to\n\nhave no length. User-settable.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Monstera.AbstractNode","page":"-","title":"Monstera.AbstractNode","text":"The AbstractNode type is the supertype of node types. Subtypes of AbstractNode must implement the public properties listed below.\n\nPublic properties\n\nid: integer number that uniquely identifies a node in a tree. Not user-settable.\ntaxon: integer number that identifies the taxon associated to a node. User-settable.\nlabel: string to display for this node when printing, plotting, etc. User-settable.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Monstera.AssignmentSolution","page":"-","title":"Monstera.AssignmentSolution","text":"Stores the solution of an assigment problem\n\nCan be directly used to index the appropriate values from the cost matrix \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Monstera.CharCanvas","page":"-","title":"Monstera.CharCanvas","text":"CharCanvas\n\nA canvas for drawing text plots upon.\n\nDrawing coordinates are in \"X,Y\" format with the origin at the top right corner.\n\nCanvases are created filled with , and the first occurence of  in a line causes  printing to skip the rest of the line and move on to the next. The paint_white_background function can be used to change ' ' to ' ' in selected areas. This awkward system exists to prevent printing excessive right-padding whitespaces, which makes tree plots more prone to deforming when resizing the text area.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Monstera.TaxonBipartition","page":"-","title":"Monstera.TaxonBipartition","text":"TaxonBipartition\n\nBit-vector that tags taxa in a list as belonging to one of two disjoint groups.\n\nBeware that many functions assume that bipartitions are normalised so that the first bit is always naught (see Penny & Hendy 1985).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Monstera.TaxonSet","page":"-","title":"Monstera.TaxonSet","text":"TaxonSet([taxon_names])\nTaxonSet(n::Int)\n\nAn ordered collection of taxa with unique names.\n\nTaxonSets can be created empty, or from a vector of name strings, or by giving a number n, which creates taxa successively named \"1\" through \"n\".\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Monstera.Newick.parse-Tuple{Type, String, Monstera.Newick.ReaderSettings}","page":"-","title":"Monstera.Newick.parse","text":"Newick.parse(T, string, settings)\n\nParse a string in Newick format as a tree of type T.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.Newick.parse_branch!-Tuple{IO, AbstractBranch}","page":"-","title":"Monstera.Newick.parse_branch!","text":"After reading ':'\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.Newick.parse_comment-Tuple{Any, Any}","page":"-","title":"Monstera.Newick.parse_comment","text":"After reading '['. Doesn't work with arrays yet!\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.Newick.parse_quoted-Tuple{IO, Char, Char}","page":"-","title":"Monstera.Newick.parse_quoted","text":"Parse a quoted string after Base.reading the first quote (qchar to specify ''' vs '\"'), with escape character escchar\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.Newick.read-Tuple{AbstractString, Type, Monstera.Newick.ReaderSettings}","page":"-","title":"Monstera.Newick.read","text":"Newick.read(file, sink)\nNewick.read(io, sink)\n\nRead trees from a file in Newick format.\n\nThe sink argument specifies the concrete type that will be used to represent the trees. It can correspond to an AbstractTree subtype or a vector thereof. If a tree type is given, only the first Newick string in the file will be read. If a vector of a tree type is given,  all the Newick strings in the file will be read.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.Newick.string-Tuple{Any, Monstera.Newick.WriterSettings}","page":"-","title":"Monstera.Newick.string","text":"Newick.string(tree, <keyword arguments or writer settings object>)\nNewick.string(node, <keyword arguments or writer settings object>)\nNewick.string(branch => node, <keyword arguments or writer settings object>)\n\nReturn a string with the Newick representation of a tree.\n\nThe string format can be optionally customised by passing a WriterSettings object, or with  the keyword arguments below.\n\nSee also Newick.read, Newick.WriterSettings\n\nArguments\n\nbrlength::Bool=true: whether to write branch lengths\nlabel_quote::Bool=false: wheteher to write double quote marks around node labels\nbrlength_digits::Int=308: branch lengths will be rounded to this number\nskip_nanlength::Bool=false: whether to write the length of a branch when it is NaN\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.Newick.write-Tuple{IO, Any, Monstera.Newick.WriterSettings}","page":"-","title":"Monstera.Newick.write","text":"Newick.write(<file name or io>, tree, <keyword arguments or writer settings object>)\nNewick.write(<file name or io>, node, <keyword arguments or writer settings object>)\nNewick.write(<file name or io>, branch => node, <keyword arguments or writer settings object>)\n\nWrite the Newick representation of a tree to an IOBuffer or a file.\n\nThe Newick string format can be optionally customised by passing a NewickWriterSettings  object, or with the keyword arguments below.\n\nSee also Newick.string, Newick.WriterSettings\n\nArguments\n\nbrlength::Bool=true: whether to write branch lengths\nlabel_quote::Bool=false: wheteher to write double quote marks around node labels\nbrlength_digits::Int=308: branch lengths will be rounded to thisnumber\nskip_nanlength::Bool=false: whether to write the length of a branch when it is NaN\n\nWriting to file\n\nappend=false: whether to append to the file\nlock=true: lock operations for safe multi-threaded access.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Monstera.Newick.ReaderSettings","page":"-","title":"Monstera.Newick.ReaderSettings","text":"Newick.ReaderSettings(taxonset = TaxonSet(); taxafrom=:outer)\n\nSettings for reading Newick strings.\n\nNode labels can be interpreted as taxon names. Taxon names will be mapped to the  corresponding taxon in the taxon set, or added to the taxon set if they were not already  present.\n\nThe taxafrom keyword argument is used to customise which node labels will be interpeted as taxon names, with any of the following values:\n\n:outer (default) only outer nodes\n:inner only inner nodes\n:all all nodes\n:none no nodes\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Monstera.Newick.WriterSettings","page":"-","title":"Monstera.Newick.WriterSettings","text":"Newick.WriterSettings(args)\n\nSettings for writing Newick strings.\n\nArguments\n\nbrlength::Bool=true: whether to write branch lengths\nlabel_quote::Bool=false: wheteher to write double quote marks around node labels\nbrlength_digits::Int=308: branch lengths will be rounded to this number of digits\nskip_nanlength::Bool=true: whether to write the length of a branch when it is NaN\n\n\n\n\n\n","category":"type"}]
}
